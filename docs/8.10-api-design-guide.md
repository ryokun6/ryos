# ryOS API Design Guide

This document outlines the patterns and conventions used in the ryOS API.

## Architecture Overview

The API uses Vercel serverless functions with Node.js runtime for all endpoints. This provides full Node.js API access including native modules like `bcrypt` for password hashing.

## File Structure

```
api/
├── _utils/                    # Shared utilities (global)
│   ├── middleware.ts          # Main middleware (consolidated utilities)
│   ├── redis.ts               # Redis client factory
│   ├── constants.ts           # Centralized constants
│   ├── _cors.ts               # CORS handling
│   ├── _rate-limit.ts         # Rate limiting
│   ├── _validation.ts         # Input validation
│   └── auth/                  # Authentication utilities
│       ├── index.ts           # Main auth exports
│       ├── _validate.ts       # Token validation
│       ├── _tokens.ts         # Token management
│       ├── _extract.ts        # Request auth extraction
│       ├── _constants.ts      # Auth-specific constants
│       └── _types.ts          # TypeScript types
├── auth/                      # Authentication endpoints
├── rooms/                     # Chat room endpoints
│   ├── _helpers/              # Room-specific helpers
│   │   ├── _constants.ts
│   │   ├── _presence.ts
│   │   ├── _redis.ts
│   │   ├── _types.ts
│   │   └── ...
│   ├── [id]/                  # Dynamic room routes
│   └── index.ts               # Room list endpoint
├── songs/                     # Music library endpoints
│   ├── _*.ts                  # Song-specific helpers
│   ├── [id].ts                # Single song endpoint
│   └── index.ts               # Song list endpoint
└── ...                        # Other endpoints
```

### Naming Conventions

- `_helpers/` - Domain-specific helper modules (internal to a feature)
- `_utils/` - Global shared utilities
- `_*.ts` - Internal/private helper files (prefixed with underscore)
- `index.ts` - Main entry point for a feature
- `[param].ts` - Dynamic route handlers

## Common Patterns

### 1. Runtime Declaration

```typescript
// Node.js runtime (standard for all endpoints)
export const runtime = "nodejs";
export const maxDuration = 30; // optional timeout in seconds (default 10, max 60)
```

### 2. Imports from Middleware

```typescript
import {
  // Redis
  createRedis,
  
  // CORS
  getEffectiveOrigin,
  isAllowedOrigin,
  preflightIfNeeded,
  
  // Auth
  extractAuth,
  extractAuthNormalized,
  
  // Response helpers
  jsonResponse,
  errorResponse,
  successResponse,
  rateLimitResponse,
  
  // Rate limiting
  getClientIp,
  checkRateLimit,
  RATE_LIMITS,
  
  // Request helpers
  parseJsonBody,
  getQueryParam,
  
  // Request context (reduces boilerplate)
  createRequestContext,
  
  // Constants
  REDIS_PREFIXES,
  TTL,
  RATE_LIMIT_TIERS,
} from "./_utils/middleware.js";
```

### 3. Basic Handler Structure

```typescript
export default async function handler(req: Request) {
  const origin = getEffectiveOrigin(req);
  
  // Handle CORS preflight
  if (req.method === "OPTIONS") {
    const preflight = preflightIfNeeded(req, ["GET", "POST", "OPTIONS"], origin);
    if (preflight) return preflight;
    return new Response(null, { status: 204 });
  }

  // Check origin
  if (!isAllowedOrigin(origin)) {
    return errorResponse("Unauthorized", 403, origin);
  }

  // Method check
  if (req.method !== "GET" && req.method !== "POST") {
    return errorResponse("Method not allowed", 405, origin);
  }

  // Create Redis client
  const redis = createRedis();

  try {
    // Handler logic here
    return jsonResponse({ data: "example" }, 200, origin);
  } catch (error) {
    console.error("Error:", error);
    return errorResponse("Internal server error", 500, origin);
  }
}
```

### 4. Using Request Context (Recommended for Complex Handlers)

```typescript
export default async function handler(req: Request) {
  const ctx = await createRequestContext(req, { requireAuth: true });
  
  // Handle CORS preflight
  if (req.method === "OPTIONS") {
    const preflight = preflightIfNeeded(req, ["POST", "OPTIONS"], ctx.origin);
    if (preflight) return preflight;
    return new Response(null, { status: 204 });
  }

  if (!ctx.originAllowed) {
    return errorResponse("Unauthorized", 403, ctx.origin);
  }

  if (!ctx.user) {
    return errorResponse("Authentication required", 401, ctx.origin);
  }

  ctx.log("Processing request for user", { username: ctx.user.username });

  // Handler logic using ctx.redis, ctx.user, etc.
}
```

### 5. Authentication

```typescript
import { validateAuthToken } from "./_utils/auth/index.js";

// Extract and validate auth
const authHeader = req.headers.get("authorization");
const usernameHeader = req.headers.get("x-username");
const token = authHeader?.startsWith("Bearer ") ? authHeader.slice(7) : null;

const authResult = await validateAuthToken(redis, usernameHeader, token, {
  allowExpired: true,  // Allow tokens within grace period
});

if (!authResult.valid) {
  return errorResponse("Unauthorized", 401, origin);
}
```

### 6. Rate Limiting

```typescript
import { checkRateLimit, RATE_LIMITS } from "./_utils/middleware.js";

// Using preset configurations
const rlResult = await checkRateLimit(
  req,
  RATE_LIMITS.burst("my-endpoint"),
  user,  // optional authenticated user
  origin
);

if (!rlResult.allowed) {
  return rlResult.error!;
}

// Or use rateLimitResponse helper
const ip = getClientIp(req);
const rlKey = RateLimit.makeKey(["rl", "endpoint", "ip", ip]);
const result = await RateLimit.checkCounterLimit({
  key: rlKey,
  windowSeconds: 60,
  limit: 30,
});

if (!result.allowed) {
  return rateLimitResponse(origin, 30, result.resetSeconds ?? 60);
}
```

### 7. Response Helpers

```typescript
// Success with data
return jsonResponse({ items: data }, 200, origin);

// Success response with "success: true"
return successResponse({ message: "Created" }, 201, origin);

// Error response
return errorResponse("Not found", 404, origin);

// Error with code and details
return errorResponse(
  "Validation failed",
  400,
  origin,
  "VALIDATION_ERROR",
  { field: "email", issue: "invalid format" }
);

// Rate limit response
return rateLimitResponse(origin, limit, resetSeconds, "burst");
```

### 8. Admin Check

```typescript
import { isAdmin } from "./_utils/middleware.js";

// Check if user is admin (ryo) with valid token
const adminAccess = await isAdmin(redis, username, token);
if (!adminAccess) {
  return errorResponse("Forbidden - admin access required", 403, origin);
}
```

### 9. Logging

Use the logging utility for consistent, color-coded terminal output:

```typescript
import { initLogger } from "./_utils/_logging.js";

export default async function handler(req: VercelRequest, res: VercelResponse) {
  const { requestId, logger } = initLogger();
  const startTime = Date.now();
  
  logger.request(req.method || "POST", req.url || "/api/endpoint", "endpoint-name");
  
  try {
    // Handler logic
    logger.info("Processing request", { userId: "123" });
    
    logger.response(200, Date.now() - startTime);
    res.status(200).json({ success: true });
  } catch (error) {
    logger.error("Handler failed", error);
    logger.response(500, Date.now() - startTime);
    res.status(500).json({ error: "Internal error" });
  }
}
```

**Logger Methods:**

| Method | Usage |
|--------|-------|
| `logger.request(method, url, action?)` | Log incoming request with color-coded method |
| `logger.response(status, duration?)` | Log response with status color and timing |
| `logger.info(message, data?)` | General information logging |
| `logger.warn(message, data?)` | Warning messages (yellow) |
| `logger.error(message, error?)` | Error logging (red) |
| `logger.debug(message, data?)` | Debug output (dev only) |

## Constants

Use centralized constants from `_utils/constants.ts`:

```typescript
import { REDIS_PREFIXES, TTL, RATE_LIMIT_TIERS, PASSWORD, VALIDATION } from "./_utils/constants.js";

// Redis keys
const userKey = `${REDIS_PREFIXES.users}${username}`;
const tokenKey = `${REDIS_PREFIXES.authToken}user:${username}:${token}`;

// TTLs (in seconds)
await redis.set(key, value, { ex: TTL.user }); // 90 days

// Rate limits
const limit = RATE_LIMIT_TIERS.ai.authenticated.limit;  // 15
const window = RATE_LIMIT_TIERS.ai.authenticated.window; // 5 hours
```

**Available Constants:**

| Module | Contents |
|--------|----------|
| `REDIS_PREFIXES` | Key prefixes: `authToken`, `passwordHash`, `users`, `room`, `messages`, `songMeta`, `songContent`, etc. |
| `TTL` | Expiration times: `user` (90 days), `tokenGrace` (30 days), `presence` (1 day), etc. |
| `RATE_LIMIT_TIERS` | Burst, hourly, daily, AI rate limit configs for public/authenticated/admin |
| `PASSWORD` | `minLength` (8), `maxLength` (128), `bcryptRounds` (10) |
| `VALIDATION` | Username/message/roomId regex and length constraints |
| `TOKEN` | Token byte length (32) |

## Best Practices

1. **Always validate origin** before processing requests
2. **Use response helpers** for consistent error formats
3. **Implement rate limiting** on all public endpoints
4. **Use initLogger()** for consistent request tracing and timing
5. **Use createRedis()** instead of instantiating Redis directly
6. **Set appropriate maxDuration** for long-running operations (AI: 80s, standard: 30s)
7. **Validate all user input** using the validation utilities
8. **Handle errors gracefully** with try/catch blocks

## Error Response Format

All error responses follow this format:

```json
{
  "error": "Human-readable error message",
  "code": "MACHINE_READABLE_CODE",  // optional
  "details": { ... }                // optional validation errors
}
```

Rate limit errors include additional fields:

```json
{
  "error": "rate_limit_exceeded",
  "limit": 30,
  "retryAfter": 45,
  "scope": "burst"  // optional
}
```
